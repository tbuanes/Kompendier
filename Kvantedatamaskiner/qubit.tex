\chapter{Kvantedatamaskiner}

\section{Qubits}

Den grunnleggende informasjonsenheten i vanlige datamaskiner er en \emph{bit}. En bit har enten verdien 0 eller 1 og kan representeres av et hvilket som helst fysisk objekt som har to mulige tilstander. Et enkelt eksempel er en lyspære: Vi kan tilskrive tilstanden `lyset på' verdien 1 og `lyset av' verdien 0. Et eksempel med litt mer teknologisk relevans er en kondensator. Vi kan måle spenningen mellom platene i en kondensator. Hvis spenningen er tilnærmet lik 0 (i praksis under en viss grenseverdi) svarer dette til at bit'en vår har verdi 0. Hvis spenningen er over grenseverdien har bit'en verdien 1. Vi kan endre verdien fra 0 til 1 ved å tilføre kondensatoren ladning, og endre verdien fra 1 til 0 ved å lade ut kondensatoren.

I kvantedatamaskiner er den grunnleggende enheten en \emph{qubit}. En \emph{qubit} er et kvantemekanisk system som har nøyaktig to ulike utfall av en gitt måling. Et typisk eksempel er elektron-spinnet som ble diskutert i avsnitt \ref{sec:kvante:spinn}. Hvis vi måler spinnet langs en gitt akse, f.eks. $x$-aksen, vil vi alltid få enten $+\half$ eller $-\half$. I likhet med den klassiske datamaskinen kan vi tilskrive det ene måleresultatet verdien 1 og det andre måleresultatet 0. Hvis vi leser av verdien til en qubit har den---akkurat som en bit---altså enten verdien 1 eller verdien 0.

Det som virkelig skiller en \emph{qubit} fra en \emph{bit} er hva som skjer med den når vi ikke sjekker hvilke verdi den har. En bit er et klassisk system, og den har den verdien den har inntil vi gjør noe for å endre verdien (eller noe går galt). En qubit derimot er et kvantemekanisk system og må altså beskrives av en bølgefunksjon som diskutert i avsnitt \ref{sec:kvante:psi}. Dette innebærer at vi \emph{kan} sette qubiten til å ha en bestemt verdi som vi kan lese ut igjen senere. For eksempel hvis vi preparerer elektronet vårt slik at det har spinnet rettet i $x$-retning, vil vi finne nettopp at spinnet er rettet i $x$-retning når vi senere måler det. Men vi kan også sette qubiten til å være i en \emph{superposisjon} av de to tilstandene. Som diskutert i avsnitt \ref{sec:kvante:spinn} kan vi preparere elektronet til å ha spinnet sitt i positiv $z$-retning. Hvis da senere måler verdien av spinnet i $x$-retning har vi 50\% sannsynlighet for å få verdien $+\half$ og 50\% sannsynlighet for å få verdien $-\half$. Det er akkurat som om qubiten har både verdien 0 og 1 helt frem til den blir målt, og først da ender opp med den ene eller den andre muligheten. Det er heller ikke nødvendig å la superposisjonen være slik at det er nøyaktig 50\% sannsynlighet for hvert av utfallene. Generelt kan vi ende opp med en vilkårlig fordeling av sannsynligheten på de to ulike utfallene. Det er muligheten for superposisjon mellom de to ulike utfallene som utnyttes i kvantedatamaskiner og som gjør at de kan utføre enkelte beregninger langt raskere enn klassiske datamaskiner. 

\section{Dekoherens}
Så langt har vi diskutert kvantemekaniske systemer som om de er helt stabile. Ta eksempelet med elektronet som vi preparerer med spinnet i positiv $x$-retning. Vi har da sagt at hvis vi måler verdien av spinnet i $x$-retning på et senere tidspunkt (uten å ha gjort noen andre målinger på det i mellomtiden) vil vi nødvendigvis finne at elektronet fremdeles ar spinnet i positiv $x$-retning. Dette er en grov forenkling. Dersom elektronet hadde vært fullstendig isolert fra omgivelsene til enhver tid bortsett fra når vi utfører målingen hadde det vært sant, men dette er selvfølgelig umulig å oppnå. Vi må med andre ord innse at vi har muligheten for at en annen vekselvirkning med omgivelsene enn målingen også påvirker tilstanden til elektronet. Dette fenomenet kalles \emph{dekoherens} og utgjør den sannsynligvis største teknologiske utfordringen når man skal konstruere en kvantedatamaskin. Ofte når kvantedatamaskiner omtales brukes antall qubits---per i dag er det som regel opp til noen få titalls---som et mål på hvor kraftig maskinene er, men uten informasjon om forventet tid før dekoherens ødelegger informasjonen i en qubit er dette ikke tilstrekkelig til å vurdere hvor god kvantedatamaskinen er. 

Siden fokus for denne teksten er mer på prinsippene bak kvantedatamaskiner enn praktisk realisering vil jeg ikke diskutere problemet med koherens videre. Når jeg beskriver algoritmer for kvantedatamaskiner vil jeg derfor beskrive dem som om vi har en maskin der dekoherens ikke er noe problem tilgjengelig. 